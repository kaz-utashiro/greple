#!/usr/bin/perl
##
## greple: grep with multiple keywords
##
## Copyright (c) 1991-2014 Kazumasa Utashiro
##
## Original: Mar 29 1991
;; my $rcsid = q$Id: greple,v 6.24 2014/12/31 15:15:47 utashiro Exp $;
##
## Use and redistribution for ANY PURPOSE are granted as long as all
## copyright notices are retained.  Redistribution with modification
## is allowed provided that you make your modified version obviously
## distinguishable from the original one.  THIS SOFTWARE IS PROVIDED
## BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES ARE
## DISCLAIMED.
##

use strict;
use warnings;

require 5.010;

use File::stat;
use IO::Handle;
use Getopt::Long qw(GetOptionsFromArray GetOptionsFromString);
use Pod::Usage;
use Text::ParseWords qw(shellwords);
use List::Util qw(min max first sum);
use Cwd qw(getcwd abs_path);
use Data::Dumper;
use Carp;

use utf8;
use Encode;
use Encode::Guess;

##
## Setup greple/lib to be a module directory if exists.
##
BEGIN {
    if ((my $lib = abs_path($0)) =~ s{/ \K \w+ $}{lib}x) {
	push @INC, $lib if -d "$lib/App/Greple";
    }
}

use App::Greple::Common;
use App::Greple::Colorize qw(colorize);
use App::Greple::PgpDecryptor;


=head1 NAME


greple - grep with multiple keywords


=head1 SYNOPSIS


B<greple> [B<-M>I<module>] [ B<-options> ] pattern [ file... ]

  PATTERN
    pattern              'and +must -not ?alternative &function'
    -e pattern           regex pattern match across line boundary
    -r pattern           regex pattern cannot be compromised
    -v pattern           regex pattern not to be matched
    --le pattern         lexical expression (same as bare pattern)
    --re pattern         regular expression
    --fe pattern         fixed expression
    --file file          file contains search pattern
  MATCH
    -i                   ignore case
    --need=[+-]n         required positive match count
    --allow=[+-]n        acceptable negative match count
  STYLE
    -l                   list filename only
    -c                   print count of matched block only
    -n                   print line number
    -h                   do not display filenames
    -H                   always display filenames
    -o                   print only the matching part
    -A[n]                after match context
    -B[n]                before match context
    -C[n]                after and before match context
    --join               delete newline in the matched part
    --joinby=string      replace newline in the matched text by string
    --filestyle=style    how filename printed (once, separate, line)
    --linestyle=style    how line number printed (separate, line)
    --separate           set filestyle and linestyle both "separate"
  FILE
    --glob=glob          glob target files
    --chdir              change directory before search
    --readlist           get filenames from stdin
  COLOR
    --color=when         use terminal color (auto, always, never)
    --nocolor            same as --color=never
    --colormap=color     R, G, B, C, M, Y, W, Standout, Double-struck, Underline
    --colorful           use default multiple colors
    --[no]256            use ANSI 256 colors
    --regioncolor        use different color for inside/outside regions
    --uniqcolor          use different color for unique string
    --random             use random color each time
    --face               set/unset vidual effects
  BLOCK
    -p                   paragraph mode
    --all                print whole data
    --block=pattern      specify the block of records
    --blockend=s         specify the block end mark (Default: "--\n")
  REGION
    --inside=pattern     select matches inside of pattern
    --outside=pattern    select matches outside of pattern
    --include=pattern    reduce matches to the area
    --exclude=pattern    reduce matches to outside of the area
    --strict             strict mode for --inside/outside --block
  CHARACTER CODE
    --icode=name         specify file encoding
    --ocode=name         specify output encoding
  FILTER
    --if=filter          input filter command
    --of=filter          output filter command
    --pf=filter          post process filter command
    --noif               disable default input filter
  RUNTIME FUNCTION
    --print=func         print function
    --continue           continue after print function
    --begin=func         call function before search
    --end=func           call function after search
  PGP
    --[no]pgp            decrypt and find PGP file (Default: false)
    --pgppass=phrase     pgp passphrase
  OTHER
    --norc               skip reading startup file
    --man                display command or module manual page
    --show               display module file
    -d flags             display info (f:file d:dir c:color m:misc s:stat)

=cut

my @opt_e;
my @opt_v;
my @opt_r;
my @opt_re;
my @opt_le;
my @opt_fe;
my @opt_or;

my @opt_if;
my @opt_of;
my @opt_pf;
my @opt_glob;
my @opt_icode;
my @opt_block;
my @opt_inside;
my @opt_outside;
my @opt_include;
my @opt_exclude;
my @opt_chdir;
my @opt_begin;
my @opt_end;
my $opt_noif;
my $opt_all;
my $opt_blockend;
my $opt_color = 'auto';
my $opt_256 = 1;
my @opt_colormap;
my $opt_colorful = 1;
my @opt_face;
my $opt_uniqcolor;
my $opt_random;
my $opt_regioncolor;
my $opt_icode;
my $opt_ocode;
my $opt_man;
my $opt_show;
my $opt_pgp;
my $opt_pgppass;
my $opt_passphrase_fd;
my $opt_join;
my $opt_joinby = "";
my $opt_clean;
my $opt_readlist;
my $opt_rc = 1;
my $opt_need;
my $opt_allow = 0;
my @opt_need;
my @opt_allow;
my $opt_strict = 0;
my @opt_print;
my $opt_continue;
my $opt_filestyle = 'line';
my $opt_linestyle = 'line';

my $opt_c;
my @opt_d = ();
my @opt_f;
my $opt_h;
my $opt_i;
my $opt_n;
my $opt_o;
my $opt_p;
my $opt_l;
my $opt_A = 0;
my $opt_B = 0;
my $opt_C = 0;
my $opt_H;
#my $opt_M;

my @optargs = (
    'e|and=s'            => \@opt_e,
    'r|must=s'           => \@opt_r,
    'v|not=s'            => \@opt_v,
    'or=s'               => \@opt_or,
    'le=s'               => \@opt_le,
    're=s'               => \@opt_re,
    'fe=s'               => \@opt_fe,
    'need=s'             => \@opt_need,
    'allow=s'            => \@opt_allow,
    'i|ignore-case!'     => \$opt_i,
    'l'                  => \$opt_l,
    'c|count'            => \$opt_c,
    'n|line-number!'     => \$opt_n,
    'h|no-filename'      => \$opt_h,
    'H'                  => \$opt_H,
    'filestyle|fs=s'     => \$opt_filestyle,
    'linestyle|ls=s'     => \$opt_linestyle,
    'separate',          => sub {
	$opt_filestyle = $opt_linestyle = $_[0]
    },
    'o|only-matching!'   => \$opt_o,
    'p|paragraph!'       => \$opt_p,
    'A|after-context:2'  => \$opt_A,
    'B|before-context:2' => \$opt_B,
    'C|context:2'        => \$opt_C,
    'all'                => \$opt_all,
    'f|file=s'           => \@opt_f,
    'rc!'                => \$opt_rc,
    'readlist!'          => \$opt_readlist,
    'd=s'                => \@opt_d,
    'man'                => \$opt_man,
    'show'               => \$opt_show,
    'icode=s'            => \@opt_icode,
    'ocode=s'            => \$opt_ocode,
    'join!'              => \$opt_join,
    'joinby=s'           => \$opt_joinby,
    'if=s'               => \@opt_if,
    'of=s'               => \@opt_of,
    'pf=s'               => \@opt_pf,
    'noif'               => \$opt_noif,
    'pgp!'               => \$opt_pgp,
    'pgppass=s'          => \$opt_pgppass,
    'block=s'            => \@opt_block,
    'blockend:s'         => \$opt_blockend,
    'inside=s'           => \@opt_inside,
    'outside=s'          => \@opt_outside,
    'include=s'          => \@opt_include,
    'exclude=s'          => \@opt_exclude,
    'strict!'            => \$opt_strict,
    'chdir=s'            => \@opt_chdir,
    'glob=s'             => \@opt_glob,
    'begin=s'            => \@opt_begin,
    'end=s'              => \@opt_end,
    'clean!'             => \$opt_clean,
    'quote=s'            => sub {
	$opt_color = 'always';
	push @opt_colormap, $_[1]
    },
    'color=s'            => \$opt_color,
    'colormap|colormode|addcolor|cm:s'
                         => \@opt_colormap,
    'nocolor|nocolour'   => sub { $opt_color = 'never' },
    'colorful!'          => \$opt_colorful,
    'face=s'             => \@opt_face,
    'uniqcolor|uc!'      => \$opt_uniqcolor,
    'random!'            => \$opt_random,
    '256!'               => \$opt_256,
    'regioncolor|rc!'    => \$opt_regioncolor,
    'print=s'            => \@opt_print,
    'continue!'          => \$opt_continue,
    'module|M:s'         => sub {
	warn "Use -M option before other options.\n";
	exit 2;
    },
);

sub add_option {
    push @optargs, @_;
}

my %optargs;
sub setopt {
    unless (%optargs) {
	for (my $i = 0; $i <= $#optargs; $i += 2) {
	    my($spec, $ref) = @optargs[$i, $i + 1];
	    while ($spec =~ /\G(\w+)\|?/g) {
		$optargs{$1} = $ref;
	    }
	}
    }
    my $name = shift;
    if (exists $optargs{$name}) {
	my $ref = $optargs{$name};
	if (ref $ref eq 'ARRAY') {
	    @$ref = @_;
	}
	elsif (ref $ref eq 'CODE') {
	    &$ref($name, @_);
	}
	elsif (ref $ref eq 'SCALAR') {
	    $$ref = shift;
	}
	else {
	    die "Object error.";
	}
    }
}

binmode STDERR, ":encoding(utf8)";

##
## Decode @ARGV
##
foreach (@ARGV) {
    $_ = decode 'utf8', $_ unless utf8::is_utf8($_);
}

##
## Process special option --norc
##
if (@ARGV and $ARGV[0] eq "--norc") {
    $opt_rc = 0;
    shift @ARGV;
}

##
## User customizable option handling
##
my @rcdata;

##
## Read .greplerc file
##
my $greplerc;
if ($opt_rc &&
    open(GREPLERC, "<:encoding(utf8)", "$ENV{HOME}/.greplerc")) { # XXX
    my $rc = do { local $/; <GREPLERC> };
    $greplerc = greplerc({Title => "main"}, $rc);
    push @rcdata, $greplerc;
    close GREPLERC;
}

sub greplerc {
    my $arg = ref $_[0] eq 'HASH' ? shift : {};
    my $rc = join '', grep(/\S/, @_);
    for ($rc) {
	s/^__CODE__\s*\n(.*)//ms and do_eval($1);
	s/^\s*(?:#.*)?\n//mg;
	s/\\\n//g;
    }
    new RcData($arg->{Title})->parsetext($rc);
}

##
## Process special options before using Getopt.
##
@ARGV = (module_opt($greplerc->default), module_opt(@ARGV));

sub module_opt {
    my @defaults;
    while (@_) {
	if ($_[0] =~ /^-M(.*)/) {
	    shift;
	    my $module = $1 || shift or do {
		warn "Option M requires an argument.\n";
		if (my @modules = uniq(module_list())) {
		    warn "\nAvailable modules:\n";
		    warn "\t", join("\n\t", @modules), "\n";
		}
		exit -1;
	    };
	    push @defaults, module_opt(load_module($module, \@_));
	    next;
	}
	last;
    }
    (@defaults, @_);
}
sub load_module {
    my $mod = shift;
    my $argref = shift;
    my $base = "App::Greple";
    my $call;

    ##
    ## Check -Mmod::func(arg) or -Mmod::func=arg
    ##
    if ($mod =~ s{
	^ (?<name> .* ) ::
	  (?<call>
		\w+
		(?: (?<P>[(]) | = )  ## start with '(' or '='
		(?<arg> [^)]* )      ## optional arg list
		(?(<P>) [)] | )      ## close ')' or none
	  ) $
    }{$+{name}}x) {
	$call = $+{call};
    }

    my $module = $mod;
    if (-f $module) {
	require $module;
    } else {
	$module = "${base}::${module}";
	eval "use $module";
    }
    if ($@) {
	die "$mod: Module error ($@)\n";
    }
    local *data = "${module}::DATA";
    my $rc = greplerc({Title => $mod}, (not eof *data) ? <data> : ());
    push @rcdata, $rc;
    if ($call) {
	push @opt_begin, "${module}::${call}";
    }

    ##
    ## If &getopt is defined in module, call it and replace @ARGV.
    ##
    my $getopt = "${module}::getopt";
    if (defined &$getopt) {
	no strict 'refs';
	@$argref = &$getopt(@$argref);
    }

    $rc->default;
}
sub module_list {
    grep { /^[a-z]/ }
    map  { /(\w+)\.pm$/ }
    map  { glob "$_/App/Greple/*.pm" }
    @INC;
}

##
## Handle default option and ENG{GREPLEOPTS}
##
if ($ENV{'GREPLEOPTS'}) {
    unshift @ARGV, shellwords($ENV{'GREPLEOPTS'});
}

##
## Process user defined option.
##
ARGV: for (my $i = 0; $i < @ARGV; $i++) {
    last if $ARGV[$i] eq '--';
    my($opt, $value) = split /=/, $ARGV[$i], 2;
    for my $rcdata (@rcdata) {
	if (my @s = $rcdata->getopt($opt)) {
	    @s = module_opt(@s);
	    splice @ARGV, $i, 1, ($opt, $value) if defined $value;
	    ##
	    ## Convert $<n> and $<shift>
	    ##
	    my @rest = splice @ARGV, $i;
	    s/\$<(\d+)>/$rest[$1]/ge foreach @s;
	    shift @rest;
	    s/\$<shift>/shift @rest/ge foreach @s;

	    push @ARGV, @s, @rest;
	    redo ARGV;
	}
    }
}

my @SAVEDARGV = @ARGV;
Getopt::Long::Configure qw(bundling no_getopt_compat);
GetOptions(@optargs) || pod2usage;

sub set_options {
    GetOptionsFromArray(\@_, @optargs) || pod2usage;
}

sub set_options_fromstring {
    my $string = shift;
    GetOptionsFromString($string, @optargs) || pod2usage;
}

my %opt_d;
@opt_d = split(//, join('', @opt_d));
@opt_d{@opt_d} = @opt_d;

if ($opt_d{o}) {
    warn "\@ARGV = ", join(' ', shellquote(@SAVEDARGV)), "\n";
}

my $file_code;
my $default_icode = 'utf8';	# default input encoding
my @default_icode_list = qw(euc-jp 7bit-jis);
my $output_code;
my $default_ocode = 'utf8';	# default output encoding

$output_code = $opt_ocode || $default_ocode;
binmode STDOUT, ":encoding($output_code)";

## show unused option characters
if ($opt_d{u}) {
    my $s = join('','0'..'9',"\n",'a'..'z',"\n",'A'..'Z',"\n");
    map { /^([0-9a-zA-Z])(?:\|[^=]+)*(?:=[is])?$/ && $s =~ s/$1/./ } @optargs;
    die $s;
}

## show man pages
if ($opt_man or $opt_show) {
    if (@rcdata > 1 and (my $mod = $rcdata[-1]->title) ne "main") {
	my @perldocopt = $opt_show ? '-m' : () ;
	my $jp = first { -x "$_/perldocjp" } split /:/, $ENV{PATH};
	my $perldoc = $jp ? "perldocjp" : "perldoc";
	$ENV{PERL5LIB} = join ':', @INC;
	exec "$perldoc @perldocopt App::Greple::$mod";
    }
    pod2usage({-verbose => 2});
    die;
}

## setup file encoding
if (@opt_icode) {
    @opt_icode = map { split /[,\s]+/ } @opt_icode;
    if (grep { s/^\+// } @opt_icode) {
	unshift @opt_icode, @default_icode_list;
    }
    @opt_icode = uniq(@opt_icode);
    if (@opt_icode > 1) {
	@opt_icode = grep { !/(?:auto|guess)$/i } @opt_icode;
	Encode::Guess->set_suspects(@opt_icode);
	$file_code = 'Guess';
    }
    elsif ($opt_icode[0] =~ /^(?:guess|auto)$/i) {
	Encode::Guess->set_suspects(@default_icode_list);
	$file_code = 'Guess';
    } else {
	$file_code = $opt_icode[0];
    }
}
else {
    $file_code = $default_icode;
}

## make search pattern
if (@opt_f) {
    my @patterns;
    for my $opt_f (@opt_f) {
	open my $fh, '<:encoding(utf8)', $opt_f or die "$opt_f: $!\n";
	push @patterns, [
	    map  { chomp ; s{\s*//.*}{} ; $_ }
	    grep { not m{^\s*(?:#|//|$)} }
	    <$fh>
	] ;
	close $fh;
    }
    unshift @opt_re, map { join '|', map { make_pattern($_) } @$_ } @patterns;
} else {
    if (@opt_le + @opt_re + @opt_fe + @opt_or + @opt_e + @opt_r == 0) {
	&usage if @ARGV == 0;
	unshift @opt_le, shift @ARGV;
    }
}

my @xpattern;
use constant {
    MATCH_NEGATIVE => 0,
    MATCH_POSITIVE => 1,
    MATCH_MUST => 2,
};

##
## --le
##
for (@opt_le) {
    for my $p (split /(?<!\\) +/, $_) {
	next if $p eq "";
	if ($p =~ /^\&/ and my $f = parse_func($p)) {	# &func(...)
	    push @xpattern, [MATCH_POSITIVE, $f ];
	}
	elsif ($p =~ s/^-//) {				# -pattern
	    push @opt_v, $p;
	}
	elsif ($p =~ s/^\?//) {				# ?pattern
	    push @opt_or, $p;
	}
	elsif ($p =~ s/^\+//) {				# +pattern
	    push @opt_r, $p;
	}
	else {
	    push @opt_e, $p;
	}
    }
}

for my $p (@opt_r) {
    $p = make_pattern($p);
    push @xpattern, [MATCH_MUST, qr/$p/m];
}
for my $p (@opt_e) {
    $p = make_pattern($p);
    push @xpattern, [MATCH_POSITIVE, qr/$p/m];
}
for my $p (@opt_v) {
    $p = make_pattern($p);
    push @xpattern, [MATCH_NEGATIVE, qr/$p/m];
}
if (@opt_or) {
    my $p = join('|', map { &make_pattern($_) } @opt_or);
    push @xpattern, [MATCH_POSITIVE, qr/$p/m];
}

for my $p (@opt_re) {
    $p = "(?i)$p" if $opt_i;
    push @xpattern, [MATCH_POSITIVE, qr/$p/m];
}
for my $p (@opt_fe) {
    $p = "(?i)$p" if $opt_i;
    push @xpattern, [MATCH_POSITIVE, qr/\Q$p/];
}

##
## set $opt_need and $opt_alow
##
{
    my $must = grep { $_->[0] == MATCH_MUST } @xpattern;
    my $posi = grep { $_->[0] == MATCH_POSITIVE } @xpattern;
    my $nega = grep { $_->[0] == MATCH_NEGATIVE } @xpattern;

    $opt_need = $must ? 0 : $posi;
    for (@opt_need) {
	if (/^-(\d+)$/) {	# --need -n
	    $opt_need = $posi - $1;
	}
	elsif (/^\+(\d+)$/) {	# --need +n
	    $opt_need += $1;
	}
	elsif (/^(\d+)$/) {	# --need n
	    $opt_need = $1 - $must;
	}
	else {
	    die "$_ is not valid count.\n"
	}
    }

    $opt_allow = 0;
    for (@opt_allow) {
	if (/^-(\d+)$/) {	# --allow -n
	    $opt_allow = $nega - $1;
	}
	elsif (/^\+(\d+)$/) {	# --allow +n
	    $opt_allow += $1;
	}
	elsif (/^(\d+)$/) {	# --allow n
	    $opt_allow = $1;
	}
	else {
	    die "$_ is not valid count.\n"
	}
    }
}

##
## setup input/output filter
##
my @filter;
my @filter_static;

unless ($opt_noif) {
    push(@filter,
	 [ sub { s/\.Z$//   }, 'zcat' ],
	 [ sub { s/\.g?z$// }, 'gunzip -c' ],
	 [ sub { m/\.pdf$/i }, 'pdftotext -nopgbrk - -' ],
	);
    push(@filter,
	 [ sub { s/\.gpg$// }, 'gpg --quiet --decrypt' ]) unless $opt_pgp;
}
for my $if (@opt_if) {
    my @f = split /:/, $if;
    while (@f) {
	if (@f > 1) {
	    push @filter, [ splice(@f, 0, 2) ];
	} else {
	    push @filter_static, shift(@f);
	}
    }
}

sub filter {
    my $file = shift;
    local $_ = $file;

    my @f;
    for (my $remember = ""; $remember ne $_; ) {
	$remember = $_;
	for my $p (@filter) {
	    my($exp, $command) = @$p;
	    if (ref $exp eq 'CODE' ? &$exp : eval $exp) {
		push @f, $command;
		last if $_ ne $remember;
	    }
	}
    }

    push @f, @filter_static;

    my $filter = join " | ", @f;
    $filter =~ s/{}/$file/g;
    $filter;
}

my $pgp;
if ($opt_pgp) {
    $pgp = new App::Greple::PgpDecryptor;
    if ($opt_pgppass) {
	$pgp->initialize({passphrase => $opt_pgppass});
    } elsif ($opt_passphrase_fd) {
	$pgp->initialize({passphrase_fd => $opt_passphrase_fd});
    } else {
	$pgp->initialize();
    }
    push @filter, [ sub { s/\.(pgp|gpg|asc)// }, $pgp->decrypt_command ];
}

##------------------------------------------------------------
## miscellaneous setups
##

my @argv_files;
my $start_directory;
my $need_filename = ($opt_H or $opt_l);
my $current_file;

if (@opt_chdir) {
    $start_directory = getcwd;
    @opt_chdir = uniq(map { glob $_ } @opt_chdir);
    push @argv_files, splice(@ARGV);
    unless ($opt_h or
	    (@opt_chdir == 1 and @argv_files == 1 and @opt_glob == 0)) {
	$need_filename++;
    }
}
elsif (@opt_glob) {
    push @ARGV, map(glob, @opt_glob);
}

push(@ARGV, '-') unless @ARGV || @argv_files || @opt_glob || $opt_readlist;
if ((@ARGV > 1 or $opt_readlist) and not $opt_h) {
    $need_filename++;
}

$opt_join = 1 if $opt_joinby ne "";

##------------------------------------------------------------
## colors
##
my %colormap = (
    FILE  => $opt_256 ? "G" : "G",
    LINE  => $opt_256 ? "Y" : "Y",
    BLOCKEND => "",
    );

my @colors;

if (@opt_colormap) {
    my $re_field = qr/[\w\*\?]+/;
    map {
	my $spec = pop @$_;
	my @spec;
	while ($spec =~ s/\&(\w+ (?: \( [^)]* \) )? ) ;?//x) { # &func
	    push @spec, parse_func({ pointer => 1 }, $1);
	}
	if ($spec =~ s/\b(sub\s*{.*)//) { # sub { ... }
	    push @spec, parse_func({ pointer => 1 }, $1);
	}
	push @spec, $spec if $spec ne "";
	my $c = @spec > 1 ? [ @spec ] : $spec[0];
	if (@$_ == 0) {
	    push @colors, $c;
	}
	else {
	    map { $colormap{$_} = $c }
	    map { match_glob($_, keys %colormap) }
	    @$_;
	}
    }
    map {
	if (my @field = /\G($re_field)=/gp) {
	    [ @field, ${^POSTMATCH} ];
	} else {
	    [ $_ ];
	}
    }
    map {
	m/( (?:$re_field=)*
	    (?: sub\s*\{.*
	      | (?: \([^)]*\) | [^,\s] )+
	    )
	  )/gx;
    }
    @opt_colormap;
}

my @default_color =
    $opt_256
    ? qw(D/544 D/454 D/445
	 D/455 D/545 D/554
	 D/543 D/453 D/435
	 D/534 D/354 D/345
	 D/444
	 D/433 D/343 D/334
	 D/344 D/434 D/443
	 D/333)
    : qw(RD GD BD CD MD YD);

if (@colors == 0) {
    @colors = $opt_colorful ? @default_color : $default_color[0];
}

if (@opt_face) {
    my $remove = 0;
    for my $flag (map { split // } @opt_face) {
	if ($flag eq '-' or $flag eq '+') {
	    $remove = $flag eq '-';
	    next;
	}
	map { $remove ? s/$flag//g : s/^/$flag/ } @colors;
    }
}

my $need_color = (($opt_color eq 'always')
		  or (($opt_color eq 'auto') and (!$opt_o and -t STDOUT)));

if ($opt_d{c}) {
    my $dump = sub {
	local $_ = Dumper shift;
	s/(?<=')([\w\/]+)(?=')/color($1, $1)/ge;
	$_;
    };
    warn 'colormap = ', $dump->(\%colormap);
    warn 'colors = ', $dump->(\@colors);
}

my $blockend = "--\n";
if (defined $opt_blockend) {
    ($blockend = $opt_blockend) =~ s/(?<=.)$/\n/;
}
if ($opt_C) {
    $opt_A ||= $opt_C;
    $opt_B ||= $opt_C;
}
my %stat = (
    files => 0,
    match_effective => 0,
    match_positive => 0,
    match_negative => 0,
    match_block => 0,
    time_start => [],
    time_end => [],
    );

##
## Setup functions
##
for my $set (
    [ "print"  , \@opt_print  , 0 ],
    [ "begin"  , \@opt_begin  , 0 ],
    [ "end"    , \@opt_end    , 0 ],
    [ "block"  , \@opt_block  , 1 ], # need &
    [ "inside" , \@opt_inside , 1 ], # need &
    [ "outside", \@opt_outside, 1 ], # need &
    [ "include", \@opt_include, 1 ], # need &
    [ "exclude", \@opt_exclude, 1 ], # need &
    ) {
    my($cat, $opt, $pattern) = @$set;
    for (@{$opt}) {
	/^&\w+/ or next if $pattern;
	$_ = parse_func($_) or die "$cat function format error: $_\n";
    }
}

use constant {
    REG_IN => 1, REG_OUT => 0,
};
my @reg_union = (map({ [ REG_IN,  $_ ] } @opt_inside),
		 map({ [ REG_OUT, $_ ] } @opt_outside));
my @reg_clude = (map({ [ REG_IN,  $_ ] } @opt_include),
		 map({ [ REG_OUT, $_ ] } @opt_exclude));

##------------------------------------------------------------

## patterns
if ($opt_d{m}) {
    warn "Search pattern:\n";
    for my $i (0 .. $#xpattern) {
	my($mode, $p) = @{$xpattern[$i]};
	my $type =
	    $mode == MATCH_POSITIVE ? 'and ' :
	    $mode == MATCH_NEGATIVE ? 'not ' :
	    $mode == MATCH_MUST ? 'must' :
	    'unknown';
	my $target = do {
	    if (ref $p and ref $p ne 'Regexp') {
		local $_ = Dumper $p;
		chomp;
		s/\n\s*/ /g;
		$_;
	    } else {
		"/$p/";
	    }
	};
	warn sprintf("  %s %s\n", $type,
		     @colors > 1 ? index_color($target, $i) : $target);
    }
    warn sprintf "need = %d, allow = %d\n", $opt_need, $opt_allow;
}

## record start time
if ($opt_d{s}) {
    $stat{time_start} = [times];
}

## push post-process filter
if (@opt_pf) {
    push_output_filter(\*STDOUT, @opt_pf);
}

$SIG{'QUIT'} = 'QUIT';
sub QUIT { die "Interrupted\n"; }
open SAVESTDIN,  '<&', \*STDIN or die "open: $!";
MAIN: {
    eval { &main };
    if ($@) {
	if ($@ =~ /Interrupted/) {	# interrupted
	    ;
	} else {
	    warn "$current_file: $@";
	}
	close STDIN; # wait;
	open STDIN, '<&', \*SAVESTDIN or die "open: $!\n";
	redo MAIN;
    }
}

if ($opt_uniqcolor and $opt_d{m}) {
    dump_uniqcolor();
}

## show statistic info
if ($opt_d{s}) {
    $stat{time_end} = [times];
    my @s = @{$stat{time_start}};
    my @e = @{$stat{time_end}};
    printf(STDERR "cpu %.3fu %.3fs\n", $e[0]-$s[0], $e[1]-$s[1]);
    for my $k (sort keys %stat) {
	my $v = $stat{$k};
	print STDERR "$k: ";
	if (ref $v eq 'ARRAY') {
	    local $" = ", ";
	    print STDERR "(@$v)";
	} else {
	    print STDERR $v;
	}
	print STDERR "\n";
    }
}

close STDOUT;

if ($opt_d{p}) {
    open STDOUT, ">&STDERR";
    system "ps -lww -p $$";
}

exit($stat{match_effective} == 0);

######################################################################

sub main {
    while (defined($current_file = open_nextfile())) {

	my $content = do { local $/; <STDIN> };

	warn $current_file, ":\n" if $opt_d{f};
	$pgp->reset if $pgp;
	defined $content or next;

	my $matched = grep_data(\$content);

	no warnings 'uninitialized'; # why ?
	$stat{match_effective} += $matched;
	$stat{files}++;
    } continue {
	close STDIN; # wait;	# wait for 4.019 or earlier?
	# recover STDIN for opening '-' and some weird command which needs
	# STDIN opened (like unzip)
	open STDIN, '<&', \*SAVESTDIN or die "open: $!";
    }
}

sub push_output_filter {
    my $fh = shift;
    for my $filter (reverse @_) {
	if ($opt_d{m}) {
	    warn "Push output Filter: \"$filter\"\n";
	}
	my $pid = open($fh, '|-') // die "$filter: $!\n";
	if ($pid == 0) {
	    if ($filter =~ /^&/ and my $f = parse_func($filter)) {
		local @ARGV;
		open STDIN, '<&', 0 if eof STDIN;
		callfunc(@$f);
	    } else {
		do { exec $filter } ;
		warn $@ if $@;
	    }
	    exit;
	}
    }
}

sub usage {
    pod2usage(-verbose => 0, -exitval => "NOEXIT");

    my $quote = qr/[\\(){}\|\*?]/;
    for my $rcdata (@rcdata) {
	my $title = $rcdata->title;
	if ($title eq "main") {
	    print "    User defined options:\n";
	} else {
	    print "    Module $title options:\n";
	}
	for my $name ($rcdata->options) {
	    my $help = $rcdata->help($name) || "";
	    next if $help eq 'ignore';
	    my @option = $rcdata->getopt($name, DEFAULT => 1);
	    printf("        %-20s %s\n", $name,
		   $help || join(' ', shellquote(@option)));
	}
	print "\n";
    }

    print "$rcsid\n" if $rcsid =~ /:/;

    exit 2;
}

# easy implementation. don't be serious.
sub shellquote {
    my $quote = qr/[\s\\(){}\|\*?]/;
    map { /^(-+\w+=)(.*$quote.*)$/
	      ? "$1\'$2\'"
	      :  /^(.*$quote.*)$/
	      ? "\'$1\'"
	      : $_ }
    @_;
}

sub make_pattern {
    my($p) = @_;

    my $wchar_re = qr{
	[\p{East_Asian_Width=Wide}\p{East_Asian_Width=FullWidth}]
    }x;

    if ($p =~ s/^\\Q//) {
	$p = quotemeta($p);
    } else {
	$p =~ s{
	    (
	     \[[^\]]*\] [\?\*]?	# character-class
	     |
	     \(\?[=!][^\)]*\)	# look-ahead pattern
	     |
	     \(\?\<[=!][^\)]*\)	# look-behind pattern
	    )
	    |
	    ($wchar_re+)
	    |
	    (\w+|.)
	}{
	    if (defined $1) {
		$1;
	    } elsif (defined $2) {
		join('\s*', split(//, $2));
	    } elsif (defined $3) {
		$3;
	    } else {
		die;
	    }
	}egx;

	# ( [
	$p =~ s/($wchar_re)([\(\[]+)/$1\\s*$2/g;

	# ) ]
	$p =~ s{
	    (
	     \(\?<?[=!][^\)]*\)	# look-ahead/behind pattern
	    )
	    |
	    (
		$wchar_re[\)\]]+[?]?)(?![|]|$
	    )
	}{
	    if (defined $1) {
		$1;
	    } else {
		$2 . "\\s*";
	    }
	}egx;

	# remove \s* arround space
	$p =~ s/(?:\\s\*)?\\? +(?:\\s\*)?/\\s+/g;
    }

    length($p) ? ($opt_i ? "(?i)$p" : $p) : undef;
}

sub open_nextfile {

    ##
    ## --chdir
    ##
    while (@ARGV == 0 and @opt_chdir and (@argv_files or @opt_glob)) {
	my $dir = shift @opt_chdir;
	warn "chdir $dir/\n" if $opt_d{d};
	chdir $start_directory or die "$!: $start_directory\n";
	chdir $dir or die "$!: $dir\n";
	push(@ARGV, @argv_files, map(glob, @opt_glob));
    }

    my $file;
    while (defined($file = shift(@ARGV)) ||
	   defined($file = $opt_readlist && <SAVESTDIN>)) {
	$file =~ s/\n+$//;

	if (0) {}
	elsif ($file =~ /^http:\/\//) {
	    open(STDIN, '-|') || exec("w3m -dump $file") || die "w3m: $!\n";
	}
	else {
	    open(STDIN, $file) or do {
		warn "$file: $!\n" unless -l $file;
		next;
	    };
	}

	my $input_filter;
	if (defined(&filter) && ($input_filter = &filter($file))) {
	    open(STDIN, '-|') || exec($input_filter)
		|| die "$input_filter: $!\n";
	    if ($opt_d{m}) {
		printf(STDERR "Input Filter:\n  \"$input_filter\" < %s\n",
		       $file);
	    }
	}

	binmode STDIN, ":encoding($file_code)";

	return $file;
    }
    undef;
}

######################################################################

sub grep_data {
    local *_ = shift;

    ##
    ## --begin
    ##
    for my $f (@opt_begin) {
	callfunc(@$f, &FILELABEL => $current_file);
    }

    my @result = grep_pattern(\$_, \@xpattern);

    my $matched = sum 0, map { @{$_} - 1 } @result;

    if ($opt_l) {
	print "$current_file\n" if $matched;
    }
    elsif ($opt_c) {
	print "$current_file:" if $need_filename;
	print scalar @result, "\n";
    }
    elsif (@result) {
	# open output filter
	if (@opt_of) {
	    open SAVESTDOUT, '>&', \*STDOUT or die "open: $!";
	    push_output_filter(\*STDOUT, @opt_of);
	}
	display_result($current_file, \@result);
	if (@opt_of) {
	    close STDOUT;
	    open STDOUT, '>&', \*SAVESTDOUT or die "open: $!";
	}
    }

    ##
    ## --end
    ##
    for my $f (@opt_end) {
	callfunc(@$f, &FILELABEL => $current_file);
    }

    s/./\000/gs if $opt_clean;

    $matched;
}

sub display_result {
    my $file = shift;
    my @result = @{+shift} or return;

    if ($need_filename and $opt_filestyle eq 'once') {
	print $file, ":\n";
    }

    my $need_blockend =
	$opt_blockend || $opt_p || $opt_A || $opt_B || @opt_block;

    my $line = 1;
    my $lastpos = 0;
    for my $result (@result) {

	my($block_start, $block_end) = @{shift @$result};
	my $block = substr($_, $block_start, $block_end - $block_start);
	my $need_newline = not $block =~ /\n\z/;

	for (@$result) {
	    $_->[0] = $_->[0] > $block_start ? $_->[0] - $block_start : 0;
	    $_->[1] = $_->[1] - $block_start;
	}

	for my $func (@opt_print) {
	    for ($block) {
		$_ = callfunc(@$func, &FILELABEL => $file, matched => $result);
	    }
	}
	if (@opt_print and not $opt_continue) {
	    print $block if defined $block;
	    next;
	}

	if ($opt_n) {
	    my $gap = substr($_, $lastpos, $block_start - $lastpos);
	    $line += $gap =~ tr/\n/\n/;
	}
	$lastpos = $block_end;

	if (my $nl = 0, 1) {
	    if ($need_filename and $opt_filestyle eq 'separate') {
		print _file("$current_file:");
		$nl++;
	    }
	    if ($opt_n and $opt_linestyle eq 'separate') {
		print _line("$line:");
		$nl++;
	    }
	    print "\n" if $nl;
	}

	my $mark = "\001";
	for my $matched (reverse @$result) {
	    my($ms, $me, $pi) = @$matched;
	    next if $ms == $me;

	    my $s = substr($block, $ms, $me - $ms);

	    # --random
	    if ($opt_random) {
		$pi = rand(@colors);
	    }
	    # --uniqcolor
	    elsif ($opt_uniqcolor) {
		$pi = uniqcolor($s);
	    }

	    if ($opt_join) {
		if ($opt_n and $opt_linestyle eq 'line') {
		    $s =~ s/(?<!\A)\n(?!\z)/$mark/g;
		} else {
		    $s =~ s/(?<!\A)\n(?!\z)/$opt_joinby/g;
		}
	    }
	    substr($block, $ms, $me - $ms,
		   $need_color ? index_color($s, $pi) : $s);
	}
	if ($opt_n) {
	    if ($opt_linestyle eq 'line') {
		my $increment = $block =~ /[\n$mark]/ ? 1 : 0;
		$block =~ s{(?:($mark)|(?<=\n)|\A)(?=.)}{
			    my $s = $1 ? $opt_joinby
				       : _line("$line:");
			    $line += $increment;
			    $s;
			   }gse;
	    } else {
		$line += $block =~ tr/\n/\n/;
	    }
	}

	if ($need_filename and $opt_filestyle eq 'line') {
	    my $s = _file("$file:");
	    $block =~ s/^/$s/mg;
	}

	print $block;
	print "\n" if $need_newline;
	print _blockend($blockend) if $need_blockend;
    }
}

sub _file     { unshift @_, 'FILE'     ; goto &color }
sub _line     { unshift @_, 'LINE'     ; goto &color }
sub _delim    { unshift @_, 'DELIM'    ; goto &color }
sub _blockend { unshift @_, 'BLOCKEND' ; goto &color }

my %uniqcolor;
my @uniqcolor;
sub uniqcolor {
    (my $p = shift) =~ s/\n//g;
    $uniqcolor{$p} //= do {
	push @uniqcolor, $p;
	$#uniqcolor;
    };
}
sub dump_uniqcolor {
    for my $i (0 .. $#uniqcolor) {
	warn sprintf("%d %s\n", $i, index_color($uniqcolor[$i], $i));
    }
}

sub index_color {
    my $text = shift;
    my $index = @_ ? shift : 0;
    if ($need_color and @colors) {
	$text = color($colors[$index % @colors], $text, $index);
    }
    $text;
}

sub color {
    goto &_color if ref $_[0] ne 'ARRAY';
    my @speclist = @{+shift};
    local $_ = shift;
    for my $color (@speclist) {
	$_ = _color($color, $_);
    }
    $_;
}

sub _color {
    my $color = shift;
    local $_ = shift;

    my $c = exists $colormap{$color} ? $colormap{$color} : $color;

    return $c->() if ref $c eq 'CODE';
    return $_ unless $need_color and $c;

    colorize($c, $_);
}

######################################################################

use constant {
    POSI_BASE => 0, POSI_POSI => 0, POSI_NEGA => 1, POSI_LIST => 2,
    NEGA_BASE => 3, NEGA_POSI => 3, NEGA_NEGA => 4, NEGA_LIST => 5,
    MUST_BASE => 6, MUST_POSI => 6, MUST_NEGA => 7, MUST_LIST => 8,
    INDX_POSI => 0, INDX_NEGA => 1, INDX_LIST => 2,
};

my @match_base;
BEGIN {
    $match_base[MATCH_POSITIVE] = POSI_BASE;
    $match_base[MATCH_NEGATIVE] = NEGA_BASE;
    $match_base[MATCH_MUST] = MUST_BASE;
}

sub grep_pattern {
    local *_ = shift;
    my @patterns = @{+shift};
    my @blocks;

    ##
    ## build match result list
    ##
    my @result;
    my %required = (yes => 0, no => 0);
    for my $i (0 .. $#patterns) {
	my($sw, $regex) = @{$patterns[$i]};
	my($func, @args) = do {
	    if (ref $regex eq 'ARRAY') {
		@$regex;
	    }
	    elsif (ref $regex eq 'CODE') {
		($regex);
	    }
	    else {
		(\&match_regions, pattern => $regex);
	    }
	};
	my @p = callfunc($func, @args, &FILELABEL => $current_file);
	if (@p) {
	    if ($sw eq MATCH_MUST or $sw eq MATCH_POSITIVE) {
		push @blocks, map { [ @$_ ] } @p;
		$stat{match_positive} += @p;
		$required{yes}++;
	    } else {
		$stat{match_negative} += @p;
		$required{no}++;
	    }
	    map { push @$_, $i } @p;
	}
	push @result, \@p;
    }
    $stat{match_block} += @blocks;

    ##
    ## optimization for zero match
    ##
    if ($required{yes} == 0 and $opt_need > 0) {
	return ();
    }

    ##
    ## --inside, --outside
    ##
    if (@reg_union) {
	my @tmp = map { [] } @result;
	for my $regi (0 .. $#reg_union) {
	    my($in_out, $arg) = @{$reg_union[$regi]};
	    my @select = get_regions(\$_, $arg);
	    next unless $in_out == REG_OUT or @select;
	    for my $resi (0 .. $#result) {
		my $r = $result[$resi];
		my @l = select_regions({ strict => $opt_strict },
				       $r, \@select, $in_out);
		if ($opt_regioncolor or @result == 1) {
		    map { $_->[2] = $regi } @l;
		}
		push @{$tmp[$resi]}, @l;
	    }
	}
	@result = map { [ merge_regions({sort => 1}, @$_) ] } @tmp;
    }

    ##
    ## --include, --exclude
    ##
    for my $region (@reg_clude) {
	my($in_out, $arg) = @$region;
	my @select = get_regions(\$_, $arg);
	next unless $in_out == REG_IN or @select;
	for my $r (@result) {
	    @$r = select_regions({ strict => $opt_strict },
				 $r, \@select, $in_out);
	}
    }

    ##
    ## --all
    ##
    if ($opt_all) {
	@blocks = ( [ 0, length $_ ] );
    }
    ##
    ## --block
    ##
    elsif (@opt_block) {
	@blocks = ();
	for my $re (@opt_block) {
	    push @blocks, get_regions(\$_, $re);
	}
    	@blocks = merge_regions({nojoin => 1, sort => 1}, @blocks);
    }
    ##
    ## build block list from matched range
    ##
    elsif (@blocks) {
	my $textp = \$_;
	my $sub_blocknize = optimized_blocknize();
    	@blocks =
	    merge_regions({nojoin => 1, sort => 1},
			  map({[$sub_blocknize->($textp, $_->[0], $_->[1])]}
			      @blocks));
    }

    ##
    ## build match table
    ##
    my @match_table = map { [ 0, 0, [], 0, 0, [], 0, 0, [] ] } @blocks;
    for my $i (0 .. $#result) {
	my $base = $match_base[$patterns[$i][0]];
	my @b = classify_regions({ strict => $opt_strict },
				 $result[$i], \@blocks);
	for my $bi (0 .. $#b) {
	    my $te = $match_table[$bi];
	    if (@{$b[$bi]}) {
		${$te}[$base + INDX_POSI]++;
		push @{$te->[$base + INDX_LIST]}, @{$b[$bi]};
	    } else {
		${$te}[$base + INDX_NEGA]++;
	    }
	}
    }

    show_match_table(\@match_table) if $opt_d{v};

    ##
    ## now it is quite easy to get effective blocks
    ##
    my @effective_index = grep(
	$match_table[$_][MUST_NEGA] == 0 &&
	$match_table[$_][POSI_POSI] >= $opt_need &&
	$match_table[$_][NEGA_POSI] <= $opt_allow,
	0 .. $#blocks);

    ##
    ## --block with -ABC option
    ##
    if (@opt_block and ($opt_A or $opt_B)) {
	my %mark;
	for my $i (@effective_index) {
	    map($mark{$_} = 1,
		max($i - $opt_B, 0) .. min($i + $opt_A, $#blocks));
	}
	@effective_index = sort { $a <=> $b } map { int $_ } keys %mark;
    }

    ##
    ## compose the result
    ##
    my @list = ();
    for my $bi (@effective_index) {
	my @matched = merge_regions({nojoin => $opt_o, sort => 1},
				    @{$match_table[$bi][MUST_LIST]},
				    @{$match_table[$bi][POSI_LIST]},
				    @{$match_table[$bi][NEGA_LIST]}
	    );
	if ($opt_o) {
	    push @list, map({ [ $_, $_ ] } @matched);
	} else {
	    push @list, [ $blocks[$bi], @matched ];
	}
    }

    ##
    ## ( [ [blockstart, blockend], [start, end], [start, end], ... ],
    ##   [ [blockstart, blockend], [start, end], [start, end], ... ], ... )
    ##
    return @list;
}

BEGIN {
    $Data::Dumper::Terse = 1;
}
sub show_match_table {
    my $i = 0;
    for my $t (@{+shift}) {
	my $m = Dumper($t);
	$m =~ s/\s+(?!$)/ /gs;
	printf STDERR "%d %s", $i++, $m;
    }
}

sub match_regions {
    my %arg = @_;
    my $pattern = $arg{pattern} // die "Parameter error";
    my $regex = ref $pattern eq 'Regexp' ? $pattern : qr/$pattern/m;
    my @regions;
    while (/$regex/gp) {
	##
	## this is much faster than:
	## my($s, $e) = ($-[0], $+[0]);
	##
	## calling pos() cost is not neglective, either.
	##
	my $pos = pos();
	push @regions, [ $pos - length ${^MATCH}, $pos ];
    }
    @regions;
}

sub classify_regions {
    my $opt = ref $_[0] eq 'HASH' ? shift : {};

    $opt->{strict} and goto &classify_regions_strict;

    my @list = @{+shift};
    my @by = @{+shift};
    my @table;
    for (my $i = 0; $i < @by; $i++) {
	my($from, $to) = @{$by[$i]};
	while (@list and $list[0][1] < $from) {
	    shift @list;
	}
	while (@list and $list[0][1] == $from and $list[0][0] < $from) {
	    shift @list;
	}
	my $t = $table[$i] = [];
	for (my $i = 0; ($i < @list) and ($list[$i][0] < $to); $i++) {
	    push @$t, [ @{$list[$i]} ];
	}
    }
    @table;
}

sub classify_regions_strict {
    my @list = @{+shift};
    my @by = @{+shift};
    my @table;
    for (my $i = 0; $i < @by; $i++) {
	my($from, $to) = @{$by[$i]};
	while (@list and $list[0][0] < $from) {
	    shift @list;
	}
	my $t = $table[$i] = [];
	while (@list and $list[0][0] < $to and $list[0][1] <= $to) {
	    push @$t, shift @list;
	}
    }
    @table;
}

sub select_regions {
    my $opt = ref $_[0] eq 'HASH' ? shift : {};

    $opt->{strict} and goto &select_regions_strict;

    my @list = @{+shift};
    my @by = @{+shift};
    my $in_out = shift;

    my(@outside, @inside);

    for (my $i = 0; $i < @by; $i++) {
	my($from, $to) = @{$by[$i]};
	for (my $j = 0; $j < @list and $list[$j][0] < $from; $j++) {
	    push @outside, [ @{$list[$j]} ];
	}
	while (@list and $list[0][1] < $from) {
	    shift @list;
	}
	for (my $j = 0; $j < @list and $list[$j][0] < $to; $j++) {
	    push @inside, [ @{$list[$j]} ];
	}
	while (@list and $list[0][1] < $to) {
	    shift @list;
	}
	while (@list and $list[0][0] < $to and $list[0][1] <= $to) {
	    shift @list;
	}
    }
    push @outside, @list;
    $in_out == REG_IN ? @inside : @outside;
}

sub select_regions_strict {
    my @list = @{+shift};
    my @by = @{+shift};
    my $in_out = shift;

    my(@outside, @inside);

    for (my $i = 0; $i < @by; $i++) {
	my($from, $to) = @{$by[$i]};
	while (@list and $list[0][0] < $from and $list[0][1] <= $from) {
	    push @outside, shift(@list);
	}
	while (@list and $list[0][0] < $from) {
	    shift @list;
	}
	while (@list and $list[0][0] < $to and $list[0][1] <= $to) {
	    push @inside, shift(@list);
	}
	while (@list and $list[0][0] < $to) {
	    shift @list;
	}
    }
    push @outside, @list;
    $in_out == REG_IN ? @inside : @outside;
}

sub get_regions {
    local *_ = shift;
    my $pattern = shift;

    ## function array
    if (ref $pattern eq 'ARRAY') {
	callfunc(@$pattern, &FILELABEL => $current_file);
    }
    ## pattern
    else {
	match_regions(pattern => $pattern);
    }
}

sub merge_regions {
    my $option = ref $_[0] eq 'HASH' ? shift : {};
    my $nojoin = $option->{nojoin};
    my @in = @_;
    if ($option->{sort}) {
	@in = sort({$a->[0] <=> $b->[0] || $b->[1] <=> $a->[1]
			||  (@$a > 2 ? $a->[2] <=> $b->[2] : 0)
		   } @in);
    }
    my @out;
    push(@out, shift @in) if @in;
    while (@in) {
	my $top = shift @in;

	if ($out[-1][1] > $top->[0]) {
	    $out[-1][1] = $top->[1] if $out[-1][1] < $top->[1];
	}
	elsif (!$nojoin
	       and $out[-1][1] == $top->[0]
	       ##
	       ## don't connect regions in different pattern group
	       ##
	       and (@$top < 3 or $out[-1][2] == $top->[2])
	    ) {
	    $out[-1][1] = $top->[1] if $out[-1][1] < $top->[1];
	}
	else {
	    push @out, $top;
	}
    }
    @out;
}

sub reverse_regions {
    my $from = shift;
    my $max = shift;
    my @flat = (0, map(@$_, @$from), $max);

    grep { $_->[0] != $_->[1] }
    map  { [ splice(@flat, 0, 2) ] }
    0 .. @flat / 2 - 1;
}

sub optimized_blocknize {
    my($begin, $end) = (-1, -1);
    if ($opt_p or $opt_A or $opt_B) {
	\&blocknize;
    } else {
	sub {
	    if ($begin <= $_[1] and $_[2] < $end) {
		;
	    } else {
		($begin, $end) = &blocknize;
	    }
	    ($begin, $end);
	}
    }
}

sub blocknize {
    local *_ = shift;		# text
    my($from, $to) = @_;	# range
    my $matched = substr($_, $from, $to - $from);

    my $delim = $opt_p ? "\n\n" : "\n";

    my $begin = $from;
    for (my $c = $opt_B + 1; $c; $c--) {
	if ($opt_p) {
	    $begin-- while substr($_, $begin, 2) eq "\n\n";
	}
	$begin = rindex($_, $delim, $begin - length $delim);
	last if $begin < 0;
    }
    if ($begin < 0) {
	$begin = 0;
    } else {
	$begin += length $delim;
    }

    ##
    ## This decision is quite difficult when the matched strings
    ## contains multiple newlines at the end.  I'm not sure what
    ## behavior is most intuitive.
    ##
    $to -= length $1 if $matched =~ /(\n{1,1})\z/;
    pos($_) = $to;

    my $end;
    for (my $c = $opt_A + 1; $c; $c--) {
	if ($opt_p ? /\G \n?+ (?:.+\n)* (\n+)/gx : /\G.*\n()/g) {
	    $end = pos() - length $1;
	    next;
	}
	$end = length $_;
	last;
    }
    $end // die;

    ($begin, $end);
}

######################################################################

sub callfunc {
    my $name = shift;
    no strict 'refs';
    goto &$name;
}

sub callfuncp {
    my $name = shift;
    my @argv = @_;
    sub {
	no strict 'refs';
	unshift @_, @argv;
	goto &$name;
    }
}

##
## sub { ... }
## funcname(arg1,arg2,arg3=val3)
## funcname=arg1,arg2,arg3=val3
##
sub parse_func {
    my $arg = ref $_[0] eq 'HASH' ? shift : {};
    local $_ = shift;
    my $noinline = $arg->{noinline};
    my $pointer = $arg->{pointer};

    if (not $noinline and /^sub\s*{/) {
	my $sub = eval $_;
	if ($@) {
	    warn "Error in function -- $_ --.\n";
	    die $@;
	}
	if (ref $sub eq 'CODE') {
	    $pointer ? callfuncp($sub) : [ $sub ];
	} else {
	    die "Unexpected result from eval.\n";
	}
    }
    elsif (m{
	^ &?
	  (?<name>[\w:]+)
	  (?:
	    (?: (?<P>[(]) | = )  ## start with '(' or '='
	    (?<arg> [^)]* )      ## optional arg list
	    (?(<P>) [)] | )      ## close ')' or none
	  )?
	$
    }x) {
	$pointer
	    ? callfuncp($+{name}, arg2kvlist($+{arg}))
	    : [ $+{name}, arg2kvlist($+{arg}) ];
    }
    else {
	undef;
    }
}

##
## convert "key1,key2,key3=val3" to (key1=>1, key2=>1, key3=>"val3")
##
sub arg2kvlist {
    map  { /=/ ? split(/=/, $_, 2) : ($_, 1) }
    map  { split /, */ }
    grep { defined }
    @_;
}

sub do_eval {
    my($prog, $debug) = @_;
    if ($debug || $opt_d{e}) {
	print STDERR &unctrl($prog), "\n" x ($prog !~ /\n$/);
    }
    eval $prog;
    if ($@) {
	die sprintf("eval failed in file %s on line %s\n$@",
		    (caller)[1, 2]);
    }
}

sub unctrl {
    local($_) = shift;
    s/([\000-\010\013-\037])/'^' . pack('c', ord($1)|0100)/ge;
    $_;
}

sub uniq {
    my %seen;
    grep { not $seen{$_}++ } @_;
}

##
## Implement minimum function because Text::Glob is not in standard library
##
sub match_glob {
    local $_ = shift;
    s/\?/./g;
    s/\*/.*/g;
    my $regex = qr/^$_$/;
    grep { $_ =~ $regex } @_;
}

######################################################################
package RcData;

use strict;
use warnings;

use Text::ParseWords qw(shellwords);
use List::Util qw(first);
use Data::Dumper;

sub new {
    my $class = shift;
    my $title = shift || 'main';
    bless {
	Title => $title,
	Define => [],
	Option => [],
	Help => [],
    }, $class;
}

sub title {
    my $obj = shift;
    @_  ? $obj->{Title} = shift
	: $obj->{Title};
}

sub define {
    my $obj = shift;
    my $name = shift;
    my $list = $obj->{Define};
    if (@_) {
	my $re = qr/\Q$name/;
	unshift(@$list, [ $name, $re, shift ]);
    } else {
	first { $_->[0] eq $name } @$list;
    }
}

sub expand {
    my $obj = shift;
    local *_ = shift;
    for my $defent (@{$obj->{Define}}) {
	my($name, $re, $string) = @$defent;
	s/$re/$string/g;
    }
    s/(\$ENV\{ (['"]?) \w+ \g{-1} \})/$1/xgee;
}

sub setopt {
    my $obj = shift;
    my $name = shift;
    my $list = $obj->{Option};
    my @args = shellwords(shift);
    for (@args) {
	$obj->expand(\$_);
    }
    unshift @$list, [ $name, @args ];
}

sub getopt {
    my $obj = shift;
    my($name, %opt) = @_;
    return () if $name eq 'default' and not $opt{DEFAULT};

    my $list = $obj->{Option};
    my $e = first { $_->[0] eq $name } @$list;
    my @e = $e ? @$e : ();
    shift @e;
    @e;
}

sub default {
    my $obj = shift;
    $obj->getopt('default', DEFAULT => 1);
}

sub options {
    my $obj = shift;
    reverse map { $_->[0] } @{$obj->{Option}};
}

sub help {
    my $obj = shift;
    my $name = shift;
    my $list = $obj->{Help};
    if (@_) {
	unshift(@$list, [ $name, shift ]);
    } else {
	my $e = first { $_->[0] eq $name } @$list;
	$e ? $e->[1] : undef;
    }
}

sub parsetext {
    my $obj = shift;
    my $text = shift;
    while ($text =~ /(.+)\n?/g) {
	$obj->parseline($1);
    }
    $obj;
}

sub parseline {
    my $obj = shift;
    my $line = shift;
    my($arg0, $arg1, $rest) = split(' ', $line, 3);

    ##
    ## in-line help document after //
    ##
    if (grep { $arg0 eq $_ } qw(define option defopt) and
	$rest =~ s{ \s+ // \s+ (.*) }{}x)
    {
	my $help = $1;
	$obj->help($arg1, $help);
    }

    if ($arg0 eq "define") {
	$obj->define($arg1, $rest);
    }
    elsif ($arg0 eq "option") {
	$obj->setopt($arg1, $rest);
    }
    elsif ($arg0 eq "defopt") {
	$obj->define($arg1, $rest);
	$obj->setopt($arg1, $arg1);
    }
    elsif ($arg0 eq "help") {
	$obj->help($arg1, $rest);
    }
#    elsif ($arg0 eq "set" and $arg1 eq "option") {
#	package main;
#	my @args = shellwords($rest);
#	GetOptionsFromArray(\@args, @optargs) || pod2usage;
#    }
    else {
	warn "$arg0: Unknown operator in rc file.\n";
    }

    $obj;
}

1;

######################################################################


=head1 DESCRIPTION


=head2 MULTIPLE KEYWORDS


B<greple> has almost the same function as Unix command L<egrep(1)> but
the search is done in the manner similar to search engine.  For
example, next command print lines those contain all of `foo' and `bar'
and `baz'.

    greple 'foo bar baz' ...

Each word can be found in any order and/or any place in the string.
So this command find all of following texts.

    foo bar baz
    baz bar foo
    the foo, bar and baz

If you want to use OR syntax, prepend question (`?') mark on each
token, or use regular expression.

    greple 'foo bar baz ?yabba ?dabba ?doo'
    greple 'foo bar baz yabba|dabba|doo'

This command will print the line which contains all of `foo', `bar'
and `baz' and one or more from `yabba', `dabba' or `doo'.

NOT operator can be specified by prefixing the token by minus (`-')
sign.  Next example will show the line which contain both `foo' and
bar' but none of `yabba' or `dabba' or `doo'.

    greple 'foo bar -yabba -dabba -doo'

This can be written as this using B<-e> and B<-v> option.

    greple -e foo -e bar -v yabba -v dabba -v doo
    greple -e foo -e bar -v 'yabba|dabba|doo'

If `+' is placed to positive matching pattern, that pattern is marked
as required, and match required count is automatically set to the
number of required pattern.  So

    greple '+foo bar baz'

commands implicitly set the option C<--need 1>, and consequently print
all lines including `foo'.  If you want to search lines which includes
either or both of `bar' and `baz', use like this:

    greple '+foo bar baz' --need 2
    greple '+foo bar baz' --need +1

=head2 LINE ACROSS MATCH


B<greple> also search the pattern across the line boundaries.  This is
especially useful to handle Asian multi-byte text.  Japanese text can
be separated by newline almost any place of the text.  So the search
pattern may spread out on multiple lines.

As for ascii text, space character in the pattern matches any kind of
space including newline.  Next example will search the word sequence
of `foo', `bar' and 'baz', even they spread out to multiple lines.

    greple -e 'foo bar baz'

Option B<-e> is necessary because space is taken as a token separator
in the bare or B<--le> pattern.


=head1 OPTIONS


=head2 PATTERNS


If no specific option is given, B<greple> takes the first argument as
a search pattern specified by B<--le> option.  All of these patterns
can be specified multiple times.

Command itself is written in Perl, and any kind of Perl style regular
expression can be used in patterns.  See L<perlre(1)> for detail.

Note that multiple line modifier (C<m>) is set when executed, so put
C<(?-m)> at the beginning of regex if you want to explicitly disable
it.

Order of capture group in the pattern is not guaranteed.  Please avoid
to use direct index, and use relative or named capture group instead.
For example, repeated character can be written as S<C<(\w)\g{-1}>>
or S<C<(?E<lt>cE<gt>\w)\g{c}>>.

=over 7

=item B<--le>=I<pattern>

Treat the string as a collection of tokens separated by spaces.  Each
token is interpreted by the first character.  Token start with `-'
means negative pattern, `?' means alternative, and `+' does required.

Next example print lines which contains `foo' and `bar', and one or
more of `yabba' and 'dabba', and none of `bar' and `doo'.

    greple --le='foo bar -baz ?yabba ?dabba -doo'

Multiple `?' preceded tokens are treated all mixed together.  That
means `?A|B ?C|D' is equivalent to `?A|B|C|D'.  If you want to mean
`(A or B) and (C or D)', use AND syntax instead: `A|B C|D'.

If the pattern start with ampersand (`&'), it is treated as a
function, and the function is called instead of searching pattern.
Function call interface is same as the one for block/region options.

If you have a definition of I<odd_line> function in you F<.greplrc>,
which is described in this manual later, you can print odd number
lines like this:

    greple -n '&odd_line' file

This is the summary of start character for B<--le> option:

    +  Required pattern
    -  Negative match pattern
    ?  Alternative pattern
    &  Function call

=item B<-e> I<pattern>, B<--and>=I<pattern>

Specify positive match token.  Next two commands are equivalent.

    greple 'foo bar baz'
    greple -e foo -e bar -e baz

First character is not interpreted, so next commands will search the
pattern `-baz'.

    greple -e -baz

Space characters are treated specially by B<-e> and B<-v> options.
They are replaced by the pattern which matches any number of
white spaces including newline.  So the pattern can be expand to
multiple lines.  Next commands search the series of word `foo', `bar'
and `baz' even if they are separated by newlines.

    greple -e 'foo bar baz'

=item B<-r> I<pattern>, B<--must>=I<pattern>

Specify required match token.  Next two commands are equivalent.

    greple '+foo bar baz'
    greple -r foo -e bar -e baz

=item B<-v> I<pattern>, B<--not>=I<pattern>

Specify negative match token.  Because it does not affect to the bare
pattern argument, you can narrow down the search result like this.

    greple foo pattern file
    greple foo pattern file -v bar
    greple foo pattern file -v bar -v baz

=item B<--re>=I<pattern>

Specify regular expression.  No special treatment for space and wide
characters.

=item B<--fe>=I<pattern>

Specify fixed string pattern, like fgrep.

=item B<-i>, B<--ignore-case>

Ignore case.

=item B<--need>=I<n>

=item B<--allow>=I<n>

Option to compromize matching condition.  Option B<--need> specifies
the required match count, and B<--allow> the number of negative
condition to be overlooked.

    greple --need=2 --allow=1 'foo bar baz -yabba -dabba -doo'

Above command prints the line which contains two or more from `foo',
`bar' and `baz', and does not include more than one of `yabba',
`dabba' or `doo'.

Using option B<--need>=I<1>, B<greple> produces same result as B<grep>
command.

    grep -e foo -e bar -e baz
    greple --need=1 -e foo -e bar -e baz

When the count I<n> is negative value, it is subtracted from default
value.

=item B<-f> I<file>, B<--file>=I<file>

Specify the file which contains search pattern.  When file contains
multiple lines, patterns on each lines are search in OR context.

Blank line and the line starting with sharp (#) character is ignored.
Two slashes (//) and following string are taken as a comment and
removed with preceding spaces.

Multiple file can be specified, but they will be mixed into single
pattern.

=back


=head2 STYLES


=over 7

=item B<-l>

List filename only.

=item B<-c>, B<--count>

Print count of matched block.

=item B<-n>, B<--line-number>

Show line number.

=item B<-h>, B<--no-filename>

Do not display filename.

=item B<-H>

Display filename always.

=item B<-o>

Print matched string only.

=item B<-A>[I<n>], B<--after-context>[=I<n>]

=item B<-B>[I<n>], B<--before-context>[=I<n>]

=item B<-C>[I<n>], B<--context>[=I<n>]

Print I<n>-blocks before/after matched string.  The value I<n> can be
omitted and the default is 2.  When used with B<--paragraph> or
B<--block> option, I<n> means number of paragraph or block.

Actually, these options expand the area of logical operation.  It
means

    grep -C1 'foo bar baz'

matches following text.

    foo
    bar
    baz

Moreover

    greple -C1 'foo baz'

also matches this text, because matching blocks around `foo' and `bar'
overlaps each other and makes single block.

=item B<--join>

=item B<--joinby>=I<string>

Convert newline character found in matched string to empty or specifed
I<string>.  Using B<--join> with B<-o> (only-matching) option, you can
collect searching sentence list in one per line form.  This is
sometimes useful for Japanese text processing.  For example, next
command prints the list of KATAKANA words, including those spread
across multiple lines.

    greple -ho --join '\p{InKatakana}+(\n\p{InKatakana}+)*'

Space separated word sequence can be processed with B<--joinby>
option.  Next exapmle prints all `for *something*' pattern in pod
documents within Perl script.

    greple -Mperl --pod -ioe '\bfor \w+' --joinby ' '

=item B<--filestyle>=I<line>|I<once>|I<separate>, B<--fs>

Default style is I<line>, and B<greple> prints filename at the
beginning of each line.  Style I<once> prints the filename only once
at the first time.  Style I<separate> prints filename in the separate
line before each line or block.

=item B<--linestyle>=I<line>|I<separate>, B<--ls>

Default style is I<line>, and B<greple> prints line numbers at the
beginning of each line.  Style I<separate> prints line number in the
separate line before each line or block.

=item B<--separate>

Shortcut for B<--filestyle>=I<separate> B<--linestyle>=I<separate>.
This is convenient to use block mode search and visiting each location
from supporting tool, such as Emacs.

=back


=head2 FILES


=over 7

=item B<--glob>=I<pattern>

Get files matches to specified pattern and use them as a target files.
Using B<--chdir> and B<--glob> makes easy to use B<greple> for fixed
common job.

=item B<--chdir>=I<directory>

Change directory before processing files.  When multiple directories
are specified in B<--chdir> option, by using wildcard form or
repeating option, B<--glob> file expantion will be done for every
directories.

    greple --chdir '/usr/man/man?' --glob '*.[0-9]' ...

=item B<--readlist>

Get filenames from standard input.  Read standard input and use each
line as a filename for searching.  You can feed the output from other
command like L<find(1)> for B<greple> with this option.  Next example
searches string from files modified within 7 days:

    find . -mtime -7 -print | greple --readlist pattern

Using B<find> module, this can be done like:

    greple -Mfind . -mtime -7 -- pattern

=back


=head2 COLORS


=over 7

=item B<--color>=I<auto>|I<always>|I<never>, B<--nocolor>

Use terminal color capability to emphasize the matched text.  Default
is `auto': effective when STDOUT is a terminal and option B<-o> is not
given, not otherwise.  Option value `always' and `never' will work as
expected.

Option B<--nocolor> is alias for B<--color>=I<never>.

=item B<--colormap>=I<RGBCYMKWrgbcymkwSUDF>, B<--quote>=I<start>,I<end>

Specify color map.  Default is RD: RED and BOLD.

COLOR is combination of single character representing uppercase
foreground color :

    R  Red
    G  Green
    B  Blue
    C  Cyan
    M  Magenta
    Y  Yellow
    K  Black
    W  White

and corresponding lowercase background color :

    r, g, b, c, m, y, k, w

or RGB value if using ANSI 256 color terminal :

    FORMAT:
        foreground[/background]

    COLOR:
        000 .. 555       : 6 x 6 x 6 216 colors
        000000 .. FFFFFF : 24bit RGB mapped to 216 colors

    Sample:
        005     0000FF        : blue foreground
           /505       /FF00FF : magenta background
        000/555 000000/FFFFFF : black on white
        500/050 FF0000/00FF00 : red on green

and other effects :

    S  Standout (reverse video)
    U  Underline
    D  Double-struck (boldface)
    F  Flash (blink)

If the mode string contains colon `:' character, they are used to
quote the matched string.  If you want to quote the pattern by angle
bracket, use like this.

    greple --quote='<:>' pattern

Option B<--quote> is an alias for B<--colormap>, but it set the
option B<--color>=I<always> at the same time.

Multiple colors can be specified separating by white space or comma,
or by repeating options.  Those colors will be applied for each
pattern keywords.  Next command will show word `foo' in red, `bar' in
green and `baz' in blue.

    greple --colormap='R G B' 'foo bar baz'

    greple --cm R -e foo --cm G -e bar --cm B -e baz

=item B<--colormap>=I<field>=I<color>,I<field>=I<color>,...

Another form of colormap option to specify the color for fields:

    FILE      File name
    LINE      Line number
    BLOCKEND  Block end mark

=item B<--colormap>=I<&func> B<--colormap>=I<sub{...}>

You can also set the name of perl subroutine name or definition to be
called handling matched words.  Target word is passed as variable
C<$_>, and the return value of the subroutine will be displayed.

Next command convert all words in C comment to upper case.

    greple --all --include '/\*(?s:.*?)\*/' '\w+' --cm 'sub{uc}'

Note that the form of I<&func> can be used just in the same way as
other color specifications. However, if it start with I<sub{> pattern,
all the rest of the argument is taken as a part of subroutine
definition.  So, it can not be combined with other color definitions.

It is possible to use this definition with field names.  Next example
print line numbers in seven digits.

    greple -n --cm 'LINE=sub{s/(\d+)/sprintf("%07d",$1)/e;$_}'

Experimentally, these function can be combined with other normal color
specifications.  Also the form I<&func;> can be repeated.

    greple --cm 'BF/544;sub{uc}'

    greple --cm 'R;&func1;&func2;&func3'

=item B<--[no]colorful>

Shortcut for B<--colormap>='I<RD GD BD CD MD YD>' in ANSI 16 colors
mode, and B<--colormap>='I<D/544 D/454 D/445 D/455 D/454 D/554>' and
other combination of 3, 4, 5 for 256 colors mode.  Enabled by default.

=item B<--[no]256>

Set/unset ANSI 256 color mode.  Enabled by default.

=item B<--regioncolor>

Use different colors for each B<--inside>/B<outside> regions.
Disabled by default.

=item B<--uniqcolor>

Use different colors for different string matched.
Disabled by default.

Next example prints all words start by `color' and display them all in
different colors.

    greple --uniqcolor 'colou?r\w*'

=item B<--random>

Use random selected color to display matched string each time.
Disabled by default.

=item B<--face>=[-+]I<effect>

Set or unset specified I<effect> for all color specs.  Use `+'
(optional) to set, and `-' to unset.  Effect is a single character
expressing: S (Standout), U (Underline), D (Double-struck), F (Flash).

Next example romove D (double-struck) effect.

    greple --face -D

Multiple effects can be set/unset at once.

    greple --face SF-D

=back


=head2 BLOCKS


=over 7

=item B<-p>, B<--paragraph>

Print the paragraph which contains the pattern.  Each paragraph is
delimited by two or more successive newline characters by default.  Be
aware that an empty line is not paragraph delimiter if which contains
space characters.  Example:

    greple -np 'setuid script' /usr/man/catl/perl.l

    greple -pe '^struct sockaddr' /usr/include/sys/socket.h

It changes the unit of context specified by B<-A>, B<-B>, B<-C>
options.

=item B<--all>

Treat entire file contents as a single block.  This is almost
identical to following command.

    greple --block='(?s).*'

=item B<--block>=I<pattern>, B<--block>=I<&sub>

Specify the record block to display.  Default block is a single line.

Next example behave almost same as B<--paragraph> option, but is less
efficient.

    greple --block='(.+\n)+'

Next command treat the data as a series of 10-line blocks.

    greple -n --block='(.*\n){1,10}'

When blocks are not continuous and there are gaps between them, the
match occurred outside blocks are ignored.

If multiple block options are supplied, overlapping blocks are merged
into single block.

Please be aware that this option is sometimes quite time consuming,
because it finds all blocks before processing.

=item B<--blockend>=I<string>

Change the end mark displayed after B<-pABC> or B<--block> options.
Default value is "--\n".

=back


=head2 REGIONS


=over 7

=item B<--inside>=I<pattern>

=item B<--outside>=I<pattern>

Option B<--inside> and B<--outside> limit the text area to be matched.
For simple example, if you want to find string `and' not in the word
`command', it can be done like this.

    greple --outside=command and

The block can be larger and expand to multiple lines.  Next command
searches from C source, excluding comment part.

    greple --outside '(?s)/\*.*?\*/'

Next command searches only from POD part of the perl script.

    greple --inside='(?s)^=.*?(^=cut|\Z)'

When multiple B<inside> and B<outside> regions are specified, those
regions are mixed up in union way.

In multiple color environment, and if single keyword is specified,
matches in each B<--inside>/B<outside> regions are printed in
different colors.  Forcing this operation with multiple keywords, use
B<--regioncolor> option.

=item B<--inside>=I<&function>

=item B<--outside>=I<&function>

If the pattern name begins by ampersand (&) character, it is treated
as a name of subroutine which returns a list of blocks.  Using this
option, user can use arbitrary function to determine from what part of
the text they want to search.  User defined function can be defined in
F<.greplerc> file or by module option.

=item B<--include>=I<pattern>

=item B<--exclude>=I<pattern>

=item B<--include>=I<&function>

=item B<--exclude>=I<&function>

B<--include>/B<exclude> option behave exactly same as
B<--inside>/B<outside> when used alone.

When used in combination, B<--include>/B<exclude> are mixed in AND
manner, while B<--inside>/B<outside> are in OR.

Thus, in the next example, first line prints all matches, and second
does none.

    greple --inside PATTERN --outside PATTERN

    greple --include PATTERN --exclude PATTERN

You can make up desired matches using B<--inside>/B<outside> option,
then remove unnecessary part by B<--include>/B<exclude>

=item B<--strict>

Limit the match area strictly.

By default, B<--block>, B<--inside>/B<outside>,
B<--include>/B<exclude> option allows partial match within the
specified area.  For instance,

    greple --inside and command

matches pattern C<command> because the part of matched string is
included in specified inside-area.  Partial match failes when option
B<--strict> provided, and longer string never matches within shorter
area.

=back


=head2 CHARACTER CODE


=over 7

=item B<--icode>=I<code>

Target file is assumed to be encoded in utf8 by default.  Use this
option to set specific encoding.  When handling Japanese text, you may
choose from 7bit-jis (jis), euc-jp or shiftjis (sjis).  Multiple code
can be supplied using multiple option or combined code names with
space or comma, then file encoding is guessed from those code sets.
Use encoding name `guess' for automatic recognition from default code
list which is euc-jp and 7bit-jis.  Following commands are all
equivalent.

    greple --icode=guess ...
    greple --icode=euc-jp,7bit-jis ...
    greple --icode=euc-jp --icode=7bit-jis ...

Default code set are always included suspect code list.  If you have
just one code adding to suspect list, put + mark before the code name.
Next example does automatic code detection from euc-kr, ascii, utf8
and UTF-16/32.

    greple --icode=+euc-kr ...

=item B<--ocode>=I<code>

Specify output code.  Default is utf8.

=back


=head2 FILTER


=over 7

=item B<--if>=I<filter>, B<--if>=I<EXP>:I<filter>:I<EXP>:I<filter>:...

You can specify filter command which is applied to each files before
search.  If only one filter command is specified, it is applied to all
files.  If filter information include multiple fields separated by
colons, first field will be perl expression to check the filename
saved in variable $_.  If it successes, next filter command is pushed.
These expression and command list can be repeated.

    greple --if=rev perg
    greple --if='/\.tar$/:tar tvf -'

If the command doesn't accept standard input as processing data, you
may be able to use special device:

    greple --if='nm /dev/stdin' crypt /usr/lib/lib*

Filters for compressed and gzipped file is set by default unless
B<--noif> option is given.  Default action is like this:

    greple --if='s/\.Z$//:zcat:s/\.g?z$//:gunzip -c'

=item B<--noif>

Disable default input filter.  Which means compressed files will not
be decompressed automatically.

=item B<--of>=I<filter>, B<--of>=I<&func>

Specify output filter which process the output of B<greple> command.
Filter command can be specified in multiple times, and they are
invoked for each file to be processed.  So next command reset the line
number for each files.

    greple --of 'cat -n' string file1 file2 ...

If the filter start with C<&>, perl subroutine is called instead of
external command.  You can define the subroutine in F<.greplrc> or
modules.

Output filter command is executed only when matched string exists to
avoid invoking many unnecessary processes.  No effect for option
B<-c>.

=item B<--pf>=I<filter>, B<--pf>=I<&func>

Similar to B<--of> filter but invoked just once and takes care of
entire output from B<greple> command.

=back


=head2 RUNTIME FUNCTIONS


=over 7

=item B<--print>=I<function>, B<--print>=I<sub{...}>

Specify user defined function executed before data print.  Text to be
printed is replaced by the result of the funcion.  Arbitrary function
can be defined in F<.greplerc> file.  Matched data is placed in
variable C<$_>.  Other information is passed by key-value pair in the
arguments.  Filename is passed by C<file> key.  Matched informaiton is
passed by C<matched> key, in the form of perl array reference:
C<[[start,end],[start,end]...]>.

Simplest function is B<--print>='I<sub{$_}>'.  Coloring capability can
be used like this:

    # ~/.greplerc
    __CODE__
    sub print_simple {
        my %attr = @_;
        for my $r (reverse @{$attr{matched}}) {
            my($s, $e) = @$r;
            substr($_, $s, $e - $s, color('B', substr($_, $s, $e - $s)));
        }
        $_;
    }

Then, you can use this function in the command line.

    greple --print=print_simple ...

It is possible to use multiple B<--print> options.  In that case,
second function will get the result of the first function.  The
command will print the final result of the last funciton.

=item B<--continue>

When B<--print> option is given, B<greple> will immediately print the
result returned from print function and finish the cycle.  Option
B<--continue> forces to continue normal printing process after print
function called.  So please be sure that all data being consistent.

=item B<--begin>=I<function>(I<...>), B<--begin>=I<function>=I<...>

=item B<-M>I<module>::I<function(...)>, B<-M>I<module>::I<function=...>

Option B<--begin> specify the function executed at the beginning of
each file processing.  This I<function> have to be called from B<main>
package.  So if you define the function in the module package, use the
full package name or export properly.

It can be set with module option, following module name.  In this
form, the function will be called with module package name.  So you
don't have to export it.

=item B<--end>=I<function>(I<...>), B<--end>=I<function>=I<...>

Option B<--end> is almost same as B<--begin>, except that the function
is called after the file processing.

=back

For these run-time functions, optional argument list can be set in the
form of C<key> or C<key=value>, connected by comma.  These arguments
will be passed to the funciton in key => value list.  Sole key will
have the value one.  Also processing file name is passed with the key
of C<FILELABEL> constant.  As a result, the option in the next form:

    --begin function(key1,key=val2)
    --begin function=key1,key=val2

    -Mmodule::function(key1,key=val2)
    -Mmodule::function=key1,key=val2

will be transformed into following function call:

    function(&FILELABEL => "filename", key1 => 1, key2 => "val2")

The function can be defined in F<.greplerc> or modules.  Assign the
arguments into hash, then you can access argument list as member of
the hash.  It's safe to delete FILELABEL key if you expect random
parameter is given.  Content of the target file can be accessed by
C<$_>.  Ampersand (C<&>) is required to avoid the hash key is
interpreted as a bare word.

    sub function {
	my %arg = @_;
	my $filename = delete $arg{&FILELABEL} or die;
	$arg{key1};             # 1
	$arg{key2};             # "val2"
	$_;                     # contents
    }


=head2 PGP


=over 7

=item B<--pgp>

Invoke PGP decrypt command for files end with I<.pgp>, I<.gpg> or
I<.asc>.  PGP passphrase is asked only once at the beginning of
command execution.

=item B<--pgppass>=I<phrase>

You can specify PGP passphrase by this option.  Generally, it is not
recommended to use.

=back


=head2 OTHERS


=over 7

=item B<--norc>

Do not read startup file: F<~/.greplerc>.

=item B<--man>

Show manual page.
Display module's manual page when used with B<-M> option.

=item B<--show>

Show module file contents.  Use with B<-M> option.

=item B<--require>=I<filename>

Include arbitrary perl program.

=begin comment

=item B<-d> I<flags>

Display informations.  Various kind of debug, diagnostic, monitor
information can be display by giving appropriate flag to -d option.

    d: directory information
    e: eval string
    f: processing file name
    m: misc debug information
    o: option related information
    p: run `ps' command before termination (on Unix)
    s: statistic information
    u: unused options
    v: internal match information

=end comment

=back


=head1 ENVIRONMENT and STARTUP FILE


Environment variable GREPLEOPTS is used as a default options.  They
are inserted before command line options.

Before starting execution, I<greple> reads the file named F<.greplerc>
on user's home directory.  Following directives can be used.

=over 7

=item B<option> I<name> string

Argument I<name> of `option' directive is user defined option name.
The rest are processed by I<shellwords> routine defined in
Text::ParseWords module.  Be sure that this module sometimes requires
escape backslashes.

Any kind of string can be used for option name but it is not combined
with other options.

    option --fromcode --outside='(?s)\/\*.*?\*\/'
    option --fromcomment --inside='(?s)\/\*.*?\*\/'

If the option named B<default> is defined, it will be used as a
default option.

For the purpose to include following arguments within replaced
strings, two special notations can be used in option definition.
String C<$E<lt>nE<gt>> is replaced by the I<n>th argument after the
substituted option, where I<n> is number start from one.  String
C<$E<lt>shiftE<gt>> is replaced by following command line argument and
the argument is removed from option list.

For example, when

    option --line --le &line=$<shift>

is defined, command

    greple --line 10,20-30,40

will be evaluated as this:

    greple --le &line=10,20-30,40

=item B<help> I<name>

If `help' directive is used for same option name, it will be printed
in usage message.  If the help message is `ignore', corresponding line
won't show up in the usage.

=item B<define> I<name> string

Directive `define' is almost same as `option', but argument is not
processed by I<shellwords> and treated just a simple text.
Metacharacters can be included without escaping.  Defined string
replacement is done only in definition in option argument.  If you
want to use the word in command line, use option directive instead.

    define :kana: \p{InKatakana}
    option --kanalist --nocolor -o --join --re ':kana:+(\n:kana:+)*'
    help   --kanalist List up Katakana string

=back

Environment variable substitution is done for string specified by
`option' and `define' directivies.  Use Perl syntax B<$ENV{NAME}> for
this purpose.  You can use this to make a portable module.

When I<greple> found C<__CODE__> line in F<.greplerc> file, the rest
of the file is evaluated as a Perl program.  You can define your own
subroutines which can be used by B<--inside>/B<outside>,
B<--include>/B<exclude>, B<--block> options.

For those subroutines, file content will be provided by global
variable C<$_>.  Expected response from the subroutine is the list of
array references, which is made up by start and end offset pairs.

For example, suppose that the following function is defined in your
F<.greplerc> file.  Start and end offset for each pattern match can be
taken as array element C<$-[0]> and C<$+[0]>.

    __CODE__
    sub odd_line {
        my @list;
        my $i;
        while (/.*\n/g) {
            push(@list, [ $-[0], $+[0] ]) if ++$i % 2;
        }
        @list;
    }

You can use next command to search pattern included in odd number
lines.

    % greple --inside '&odd_line' patten files...


=head1 MODULE


Modules can be specified only at the beginning of command line by
B<-M>I<module> option.  Name I<module> is prepended by B<App::Greple>,
so place the module file in F<App/Greple/> directory in Perl library.

If the package name is declared properly, C<__DATA__> section in the
module file will be interpreted same as F<.greplerc> file content.

Using B<-M> without module argument will print available module list.
Option B<--man> will display module document when used with B<-M>
option.  Use B<--show> option to see the module itself.

See this sample module code.  This sample define options to search
from pod, comment and other segment in Perl script.  Those capability
can be implemented both in function and macro.

    package App::Greple::perl;
    
    BEGIN {
        use Exporter   ();
        our ($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);
    
        $VERSION = sprintf "%d.%03d", q$Revision: 6.24 $ =~ /(\d+)/g;
    
        @ISA         = qw(Exporter);
        @EXPORT      = qw(&pod &comment &podcomment);
        %EXPORT_TAGS = ( );
        @EXPORT_OK   = qw();
    }
    our @EXPORT_OK;
    
    END { }
    
    my $pod_re = qr{^=\w+(?s:.*?)(?:\Z|^=cut\s*\n)}m;
    my $comment_re = qr{^(?:[ \t]*#.*\n)+}m;
    
    sub pod {
        my @list;
        while (/$pod_re/g) {
            push(@list, [ $-[0], $+[0] ] );
        }
        @list;
    }
    sub comment {
        my @list;
        while (/$comment_re/g) {
            push(@list, [ $-[0], $+[0] ] );
        }
        @list;
    }
    sub podcomment {
        my @list;
        while (/$pod_re|$comment_re/g) {
            push(@list, [ $-[0], $+[0] ] );
        }
        @list;
    }
    
    1;
    
    __DATA__
    
    define :comment: ^(\s*#.*\n)+
    define :pod: ^=(?s:.*?)(?:\Z|^=cut\s*\n)
    
    #option --pod --inside :pod:
    #option --comment --inside :comment:
    #option --code --outside :pod:|:comment:
    
    option --pod --inside '&pod'
    option --comment --inside '&comment'
    option --code --outside '&podcomment'

You can use the module like this:

    greple -Mperl --pod default greple

    greple -Mperl --colorful --code --comment --pod default greple

If special subroutine B<getopt()> is defined in the module, it is
called at the beginning with C<@ARGV> contents.  Actual C<@ARGV> is
replaced by the result of B<getopt()>.  See B<find> module as a
sample.


=head1 HISTORY


Most capability of B<greple> is derived from B<mg> command, which has
been developing from early 1990's by the same author.  Because modern
standard B<grep> family command becomes to have similar capabilities,
it is a time to clean up entire functionarities, totally remodel the
option interfaces, and change the command name. (2013.11)


=head1 AUTHOR


Kazumasa Utashiro


=head1 SEE ALSO


L<grep(1)>, L<perl(1)>

L<github|http://kaz-utashiro.github.io/greple/>


=head1 LICENSE


Copyright (c) 1991-2014 Kazumasa Utashiro

Use and redistribution for ANY PURPOSE are granted as long as all
copyright notices are retained.  Redistribution with modification is
allowed provided that you make your modified version obviously
distinguishable from the original one.  THIS SOFTWARE IS PROVIDED BY
THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES ARE
DISCLAIMED.
